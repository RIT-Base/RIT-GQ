# RIT-BOT

# Discord-to-Static-Site Content Flow: REST + Gateway Architecture

This outline details the architecture for pulling content from a Discord channel, processing it, and exposing it to a static website using a Node.js intermediary with `discord.js`.

## I. Architecture Overview

The system relies on a middle layer (the Node.js server) because static sites cannot maintain a persistent WebSocket connection to the Discord Gateway or handle Discord API authentication directly.

1. **Discord:** Source of real-time content.
2. **Node.js Server/Bot (`discord.js`):** The heart of the system. It authenticates, fetches history (REST), listens for new messages (Gateway), processes/parses content, and stores it in a cache/database.
3. **Data Store (Cache/DB):** A reliable place (like Firestore or a generated JSON file) where the static site can fetch the processed, final content.
4. **Static Site (Frontend):** Fetches content from the Data Store/API endpoint and renders it.

## II. Component 1: The Node.js Server & Discord Bot (`discord.js`)

This server handles all interaction with Discord and content processing.

### 1. Setup and Authentication (REST)

- **Libraries:** `discord.js`, `dotenv`, an HTTP framework (e.g., Express).
- **Client Initialization:** Initialize the `discord.js` client with necessary partials and Intents (e.g., `GatewayIntentBits.GuildMessages`, `GatewayIntentBits.MessageContent`).
- **Initial Data Fetch (REST):**
    - On startup, use `client.channels.fetch('CHANNEL_ID')` to get the channel object.
    - Use `channel.messages.fetch({ limit: N })` to retrieve a bulk history of messages via the **REST API**. This is crucial for bootstrapping the content list.
    - *Self-Correction/Filtering:* Implement initial filtering (e.g., only messages with a specific prefix, only messages from a specific bot/user).

### 2. The Custom Parser & Processor

- **Input:** The raw `Message` object content.
- **Core Logic:**
    - **Filtering:** Check if the message meets criteria (e.g., in a specific thread, contains a specific tag).
    - **Parsing (Markdown/Custom Format):** If the message content is raw markdown, run it through a markdown library (like `marked` or an internal function) to convert it to sanitized HTML. If it uses a custom format (e.g., `[TITLE] | Content | [TAGS]`), extract the structured data.
    - **Normalization:** Convert the processed data into a consistent JSON structure (e.g., `{ id: '...', title: '...', contentHtml: '...', date: '...' }`).

### 3. Real-Time Updates (Gateway)

- **Listener:** Use the `client.on('messageCreate', ...)` event listener. This utilizes the **Gateway (WebSockets)** for low-latency updates.
- **Logic on Create/Update/Delete:**
    - When a new message is created (`messageCreate`): Run it through the Custom Parser and save the resulting JSON object to the Data Store (see Section III).
    - When a message is updated (`messageUpdate`): Re-run the parser and update the existing entry in the Data Store.
    - When a message is deleted (`messageDelete`): Remove the corresponding entry from the Data Store.

## III. Component 2: The Data Store / Cache (Firestore Recommendation)

Since the static site cannot directly listen to the Discord Gateway, the Node.js server must write the final content to an accessible store.

- **Recommendation: Firestore**
    - **Path Structure (Public Data):** `/artifacts/{appId}/public/data/discord_content` (collection).
    - **Documents:** Each document represents one processed message.
        - `documentId`: The Discord message ID.
        - `data`: The JSON object generated by the Custom Parser.
    - **Benefit:** The static site can use the Firebase SDK to query the data instantly, benefiting from real-time updates whenever the Node server pushes a change.
- **Alternative: Static JSON Generation**
    - If using a traditional static host (like Netlify/GitHub Pages): The Node.js server could write the full list of content to a local file (`content.json`) and upload this file to the static site's asset folder whenever a change is detected.

## IV. Component 3: The Static Site (Frontend)

The website is decoupled and only concerns itself with fetching and displaying the finalized content.

### 1. Data Fetching

- **If using Firestore:** Use the Firebase JS SDK's `onSnapshot` on the `/discord_content` collection to get a real-time list of all content items.
- **If using JSON File:** Use a standard JavaScript `fetch()` request to retrieve the `content.json` file on page load.

### 2. Content Display and Rendering

- **Filtering/Sorting (Client-Side):** The frontend can implement additional filtering (e.g., by date, tag, or keyword) and sorting using client-side JavaScript.
- **Rendering:** Iterate over the content list and inject the pre-processed HTML (`contentHtml`) into the DOM.
- **Aesthetics:** Use Tailwind CSS or similar utility-first frameworks to make the displayed content clean, readable, and responsive.

This structure ensures that the computationally heavy and sensitive (API key-dependent) parts remain on your secure Node.js server, while the fast, simple, and scalable content is served to the static site.